## 动态规划

**关键词** ： 最优子结构、重叠子问题、动态转移方程、空间压缩

### 基本动态规划：一维

#### 70. 爬楼梯 [简单]

> 给定 n 节台阶，每次可以走一步或走两步，求一共有多少种方式可以走完这些台阶。

- 斐波那契数列、dp[i]、注意边界条件
- 空间压缩、用两个变量来保存 dp[i-1]、dp[i-2]

#### 198. 打家劫舍 [中等]

> 假如你是一个劫匪，并且决定抢劫一条街上的房子，每个房子内的钱财数量各不相同。如果你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。  

- dp[i] = max(dp[i-1], dp[i-2] + nums[i]);
- 空间压缩、用两个变量来保存 dp[i-1]、dp[i-2]

#### 413. 等差数列划分 [中等]

> 给定一个数组，求这个数组中连续且等差的子数组一共有多少个。 

- 要满足等差的条件、dp[i] = dp[i-1] + 1、结果是所有的 dp[i]
- 空间压缩，用一个变量来保存累加结果

### 基本动态规划：二维

#### 64. 最小路径和 [中等]

> 给定一个 m × n 大小的非负整数矩阵，求从左上角开始到右下角结束的、经过的数字的和最小的路径。每次只能向右或者向下移动。  

- dp[i] [j] = min(dp[i] [j-1], dp[i-1] [j]) + grid[i] [j]
-  空间压缩：因为 dp 矩阵的每一个值只和左边和上面的值相关，我们可以使用空间压缩将 dp 数组压缩为一维。对于第 i 行，在遍历到第 j 列的时候，因为第 j-1 列已经更新过了，所以 dp[j-1] 代表 dp[i] [j-1]的值；而 dp[j] 待更新，当前存储的值是在第 i-1 行的时候计算的，所以代表 dp[i-1] [j] 的值。  

#### 542. 01 矩阵 [中等]

> 给定一个由 0 和 1 组成的二维矩阵，求每个位置到最近的 0 的距离。 

- 从左上到右下、从右下到左上进行两次动态搜索  

#### 221. 最大正方形 [中等]

> 给定一个二维的 0-1 矩阵，求全由 1 构成的最大正方形面积。  

- dp[i] [j] = min(dp[i-1] [j-1], min(dp[i] [j-1], dp[i-1] [j])) + 1;  

### 分割类问题

#### 279. 完全平方数 [中等]

> 给定一个正整数，求其最少可以由几个完全平方数相加构成。  

- 由拉格朗日的四平方定理可得，每个自然数都可以表示为四个整数平方之和。所以结果最大为4。
- dp[i] = min(dp[i], dp[i - k*k] + 1)

#### 91. 解码方法 [中等]

> 已知字母 A-Z 可以表示成数字 1-26。给定一个数字串，求有多少种不同的字符串等价于这个数字串。  

- 分情况讨论，看当前字符能否和前一个字符组合，不同情况转移方程不同
- 注意边界条件

#### 139. 单词拆分  [中等]

> 给定一个字符串和一个字符串集合，求是否存在一种分割方式，使得原字符串分割后的子字符串都可以在集合内找到。  

- 在满足条件的情况下，
- dp[i] = dp[i] || dp[i - word.size()]

### 子序列问题

#### 300. 最长递增子序列 [中等]

> 给定一个未排序的整数数组，求最长的递增子序列。  

- dp[i] = max(dp[i], dp[j] + 1)

- 使用二分查找优化时间复杂度：遍历每一个位置 i，如果其对应的数字大于 dp 数组中所有数字的值，那么我们把它放在 dp 数组尾部，表示最长递增子序列长度加 1；如果我们发现这个数字在 dp 数组中比数字 a 大、比数字 b 小，则我们将 b 更新为此数字，使得之后构成递增序列的可能性增大。  

#### 1143. 最长公共子序列 [中等]

> 给定两个字符串，求它们最长的公共子序列长度。  

- 分两种情况

### 背包问题

#### 416. 分割等和子集 [中等]

> 给定一个正整数数组，求是否可以把这个数组分成和相等的两部分。  

- 0-1 背包、容量为总和的一般、bool 型
- dp[j] = dp[j] || dp[j-nums[i]]

#### 474. 一和零 [中等]

> 给定 m 个数字 0 和 n 个数字 1，以及一些由 0-1 构成的字符串，求利用这些数字最多可以构
> 成多少个给定的字符串，字符串只可以构成一次。  

- 二维 0-1 背包
- dp[i] [j] = max(dp[i] [j], dp[i-zero] [j-one] + 1)

#### 322. 零钱兑换 [中等]

> 给定一些硬币的面额，求最少可以用多少颗硬币组成给定的金额。  

- 多重背包
- 枚举值从小到大

### 字符串编辑

#### 72. 编辑距离 [困难]

> 给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可
> 以将两个字符串变成相同。  

- dp[i] [j] 从三个方向获得，分别是什么情况
- dp[i] [j] = min(dp[i-1] [j-1] + (word1[i-1] == word2[j-1] ? 0 : 1), min(dp[i-1] [j] + 1, dp[i] [j-1] + 1));

#### 650. 只有两个键的键盘 [中等]

> 给定一个字母 A，已知你可以每次选择复制全部字符，或者粘贴之前复制的字符，求最少需
> 要几次操作可以把字符串延展到指定长度。  

- 动态转移使用乘除法来实现，对于每个位置j，如果 j 可以被 i 整除，那么长度 i 就可以由长度 j 操作得到 
- dp[i] = min(dp[i], dp[i/j] + j);

#### 10. 正则表达式匹配 [困难]

> 给定一个字符串和一个正则表达式（regular expression, regex），求该字符串是否可以被匹配。  

- 分情况讨论
- [动态规划 - 从 0 讲解，大白话好理解 - 正则表达式匹配 - 力扣（LeetCode）](https://leetcode.cn/problems/regular-expression-matching/solution/dong-tai-gui-hua-zen-yao-cong-0kai-shi-si-kao-da-b/)
