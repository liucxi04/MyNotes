## 树

### 树的递归

#### 104. 二叉树的最大深度 [简单]

> 求一个二叉树的最大深度。  

#### 110. 平衡二叉树 [简单]

> 判断一个二叉树是否平衡。  

#### 101. 对称二叉树 [简单]

> 判断一个二叉树是否对称。  

#### 572. 另一棵树的子树 [简单] [中等]

> 判断一棵树是不是另一颗树的子树。

- 要枚举树的开始节点，然后对比时不能中断

#### 617. 合并二叉树 [简单] 

> 合并两颗二叉树。如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

#### 226. 翻转二叉树 [简单]

> 翻转一棵二叉树。

#### 543. 二叉树的直径 [简单]

> 求一个二叉树的最长直径。  

- 注意优化，不要重复递归

#### 404. 左叶子之和 [简单]

> 给定二叉树的根节点，返回所有左叶子之和。

#### 513. 找树左下角的值 [中等]

> 给定一个二叉树的根节点，请找出该二叉树的最底层最左边节点的值。

- 只记录层数即可，该层第一个就是最左边的。

#### 437. 路径总和 III [中等] [困难]

> 给定一个整数二叉树，求有多少条路径节点值的和等于给定值。  

- 一种方法是从零开始加，一种方法是从 sum 开始减
- 但是要注意中间不能中断，这条路径是连续的
- 递归每个节点时，需要分情况考虑：（1）如果选取该节点加入路径，则之后必须继续加入连续节点，或停止加入节点（2）如果不选取该节点加入路径，则对其左右节点进行重新进行考虑。因此一个方便的方法是我们创建一个辅函数，专门用来计算连续加入节点的路径。  

#### 1110. 删点成林 [中等]

> 给定一个整数二叉树和一些整数，求删掉这些整数对应的节点后，剩余的子树。  

- 理解树的递归的思路

- 进来判空，先处理左，再处理右，再处理自己，然后返回

### 树的遍历

#### 637. 二叉树的层平均值 [简单]

> 给定一个二叉树，求每一层的节点值的平均数。

- 层序遍历不需要两个队列，只要保存当前层的节点个数就行

#### 105. 从前序与中序遍历序列构造二叉树 [中等]

> 给定一个二叉树的前序遍历和中序遍历结果，尝试复原这个树。  

- 可以尝试用 hash 优化在中序遍历中的查找

#### 144. 二叉树的前序遍历 [简单]

> 二叉树的前序遍历

- 递归方式，迭代方式使用栈来实现，注意先压右子树再压左子树，因为栈先进后出

### 二叉查找树

#### 99. 恢复二叉搜索树 [中等]

> 给定一个二叉查找树，已知有两个节点被不小心交换了，试复原此树。  

- 二叉搜索树中序遍历有序，那么中序遍历一定有不满足大小顺序的节点
- 如果遍历整个序列过程中只出现了一次次序错误，说明就是这两个相邻节点需要被交换；如果出现了两次次序错误，那就需要交换这两个节点。  
- 使用一个 prev 指针指向中序遍历过程中的上一个节点，可以使空间复杂度降为 1

#### 669. 修剪二叉搜索树 [中等]

> 给定一个二叉查找树和两个整数 low 和 high，且 low < high，试修剪此二叉查找树，使得修剪后所有
> 节点的值都在 [low, high] 的范围内。  

- 利用二叉查找树的大小关系，进行递归处理
- 注意每次递归只要处理当下的情况，不需要考虑后续递归的发展

### 字典树

#### 208. 实现 Trie (前缀树) [中等] [困难]

> 尝试建立一个字典树，支持快速插入单词、查找单词、查找单词前缀的功能。  
