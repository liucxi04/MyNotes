## 第二章 构造、析构、赋值运算

### 条款 05 ：了解 C++ 默默编写并调用哪些函数

> 编译器可以暗自创建默认构造函数、拷贝构造函数、拷贝赋值运算符以及析构函数

- 默认构造函数、析构函数：用来放置藏身幕后的代码，比如调用基类或者非静态成员的构造函数。

- 拷贝构造函数：
  - 内置类型：拷贝每一个 bits
  - 类类型：调用其构造函数
- 拷贝赋值运算符：不合法时不会生成
  - 成员变量为 reference-to-non-const，（不允许 reference 改指向不同对象）
  - 成员变量为 const，（不允许更改 const 成员）
  - 基类将拷贝赋值运算符声明为 private，（派生类生成的拷贝赋值运算符无法处理基类成分）

### 条款 06 ：若不想使用编译器自动生成的函数，就应该明确拒绝

> 为驳回编译器暗自提供的功能，可将相应的成员函数声明为 private 并且不予实现，或者使用类似 Uncopyable 的基类。

- 将拷贝构造函数和拷贝赋值运算符声明为 private，
  - 阻止了编译器创建默认函数，阻止了使用者调用    ---->    编译器错误
  - 但是成员函数和友元函数还是可以调用
- 将拷贝构造函数和拷贝赋值运算符声明为 private，并且不实现它们
  - 在调用时会得到一个连接错误（linkage error）    ---->    连接器错误
- 定义 Uncopyable 基类，并将拷贝构造函数和拷贝赋值运算符声明为 private
  - 将连接期错误提前编译期

- =delete

### 条款 07 ：为多态基类声明虚析构函数

> 带多态性质的基类应该声明一个虚析构函数。如果类带有任何虚函数，它就应该拥有一个虚析构函数。
>
> 类设计的目的如果不是作为基类使用，或不是为了具备多态性，就不应该声明虚析构函数。

- 当派生类对象经由一个基类指针被删除，而该基类带着一个非虚析构函数，其结果未定义，实际执行时通常发生的是对象的派生成分没有被销毁
- 任何类只要带有虚函数都几乎确定应该也有一个虚析构函数
- 如果类不含虚函数，令其析构函数为虚是不合适的，因为会多出虚指针(vpte)和虚表(vtbl)的内存占用
- 企图继承一个标准容器或者任何其他带有非虚析构函数的类都会产生严重的后果
- 纯虚析构函数（抽象类、虚析构）

### 条款 08 ：别让异常逃离析构函数

> 析构函数绝对不要吐出异常。如果一个析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们或者结束程序
>
> 如果客户需要对某个操作函数运行期间抛出的异常作出反应，那么类应该提供一个普通函数（而非在析构函数中）执行该操作

- 析构函数吐出异常会导致程序过早结束或产生未定义的行为
- 避免异常逃离可以有强迫结束程序和吞下异常两种选择，或者重新设计接口，使用户有机会对可能出现的问题做出反应
- 如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数