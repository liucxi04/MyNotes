# Effective C++

## 第一章 让自己习惯 C++

### 条款 01 ：视 C++ 为一个语言联邦

> C++ 高效编程守则视情况而变化，取决于你使用 C++ 的哪部分

- 面向过程、面向对象、泛型、函数式、模板元编程
- C：预处理器、内置数据类型、数组、指针等
- 面向对象的 C++：构造函数、析构函数、封装、继承、多态
- 模板的C++：
- STL：容器、迭代器、算法、函数对象

### 条款 02 ：尽量以 const、enum、inline 替换 #define

> 对于单纯常量，最好以 const 对象或者 enums 替换 #define
>
> 对于形似函数的宏，最好改用 inline 函数替换 #define

- 以编译器代替预处理器，因为 #define 不被视作语言的一部分

- 常量
  - 常量指针：const int myAge = 19; int * const age = &myAge;  顶层 const
  - 指向常量的指针：const char * name;  底层 const

- 类专属常量

```c++
// 为了将常量的作用域限制于类内，必须让它成为类的一个成员；而为确保此常量至多只有一份实体，必须让它成为一个 static 成员
 class GamePlayer {
     private:
     	static const int NumTurns = 5;	// 常量声明式，而非定义式
     	int scores[NumTurns];			// 使用该常量
 }
// 对于一个类专属静态整数类型，只要不取地址，可以不提供定义式
// 以下为定义式，在类中已经获得初始值，在定义时不可以再设初值
const int GamePalyer::NumTurns;
```

- 无法利用 #define 创建一个类专属常量，因为 #define 不重视作用域
- the enum hack - 一个属于枚举类型的数值可权充 int 被使用

```c++
 class GamePlayer {
     private:
     	enum { NumTurns = 5 };
     	int scores[NumTurns];			
 }
// enum hack 的行为某方面像 #define 而不像 const
// 取一个 const 的地址是合法的，取一个 #define 或者 enum 的地址不合法
```

- template inline 函数可以获得宏函数带来的效率以及一般函数的所有可预料行为和类型安全性

### 条款 03 ：尽可能使用 const



### 条款04 ：确定对象被使用前已先被初始化



## 第二章 构造、析构、赋值运算

### 条款 05 ：了解 C++ 默默编写并调用哪些函数

> 编译器可以暗自创建默认构造函数、拷贝构造函数、拷贝赋值运算符以及析构函数

- 默认构造函数、析构函数：用来放置藏身幕后的代码，比如调用基类或者非静态成员的构造函数。

- 拷贝构造函数：
  - 内置类型：拷贝每一个 bits
  - 类类型：调用其构造函数
- 拷贝赋值运算符：不合法时不会生成
  - 成员变量为 reference-to-non-const，（不允许 reference 改指向不同对象）
  - 成员变量为 const，（不允许更改 const 成员）
  - 基类将拷贝赋值运算符声明为 private，（派生类生成的拷贝赋值运算符无法处理基类成分）

### 条款 06 ：若不想使用编译器自动生成的函数，就应该明确拒绝

> 为驳回编译器暗自提供的功能，可将相应的成员函数声明为 private 并且不予实现，或者使用类似 Uncopyable 的基类。

- 将拷贝构造函数和拷贝赋值运算符声明为 private，
  - 阻止了编译器创建默认函数，阻止了使用者调用    ---->    编译器错误
  - 但是成员函数和友元函数还是可以调用
- 将拷贝构造函数和拷贝赋值运算符声明为 private，并且不实现它们
  - 在调用时会得到一个连接错误（linkage error）    ---->    连接器错误
- 定义 Uncopyable 基类，并将拷贝构造函数和拷贝赋值运算符声明为 private
  - 将连接期错误提前编译期

- =delete

### 条款 07 ：为多态基类声明虚析构函数

> 带多态性质的基类应该声明一个虚析构函数。如果类带有任何虚函数，它就应该拥有一个虚析构函数。
>
> 类设计的目的如果不是作为基类使用，或不是为了具备多态性，就不应该声明虚析构函数。

- 当派生类对象经由一个基类指针被删除，而该基类带着一个非虚析构函数，其结果未定义，实际执行时通常发生的是对象的派生成分没有被销毁
- 任何类只要带有虚函数都几乎确定应该也有一个虚析构函数
- 如果类不含虚函数，令其析构函数为虚是不合适的，因为会多出虚指针(vpte)和虚表(vtbl)的内存占用
- 企图继承一个标准容器或者任何其他带有非虚析构函数的类都会产生严重的后果
- 纯虚析构函数（抽象类、虚析构）

### 条款 08 ：别让异常逃离析构函数

> 析构函数绝对不要吐出异常。如果一个析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们或者结束程序
>
> 如果客户需要对某个操作函数运行期间抛出的异常作出反应，那么类应该提供一个普通函数（而非在析构函数中）执行该操作

- 析构函数吐出异常会导致程序过早结束或产生未定义的行为
- 避免异常逃离可以有强迫结束程序和吞下异常两种选择，或者重新设计接口，使用户有机会对可能出现的问题做出反应
- 如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数

### 条款 09 ：绝不在构造和析构过程中调用虚函数

> 在基类构造和析构期间不要调用虚函数，因为这类调用从不下降至派生类

- 在基类构造期间，虚函数不是虚函数
- 在派生类对象的基类构造期间，对象的类型是基类而不是派生类（虚函数、typeid、dunamic_cast 都会将对象看作基类）
- 一旦派生类析构函数开始执行，对象内的派生成分便呈现未定义值，进入基类析构函数后对象就成为一个基类对象
- 要确保构造函数和析构函数内没有调用虚函数，构造函数和析构函数调用的函数也不能调用虚函数
- 令派生类将必要的构造 信息向上传递至基类构造函数来弥补虚函数无法在基类向下调用的遗憾

### 条款 10 ：令 operator= 返回一个 reference to *this

> 令赋值运算符返回一个 reference to *this

- 实现连锁赋值
- 所有赋值相关运算都要遵守（=、+= ...）

### 条款 11 ：在 operator= 中处理自我赋值

> 确保当对象自我赋值时 operator= 有良好的行为。其中技术包括：比较来源对象和目的对象的地址，精心周到的语句顺序，以及 copy-and-swap
>
> 确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确

- 错误：delete 不仅删除了 *this 的 bitmap (数据成员)，同时也删除了 rhs 的 bitmap，返回了一个指针指向的是被删除的对象    ---->    不具备自我赋值安全性，不具备异常安全性

```c++
Widget &Widget::operator= (const Widgte &rhs) {
    delete pb;
    pb = new Widget(rhs.pb);
    return *this;
}
```

- 证同测试 - 比较来源对象和目的对象的地址    ---->    不具备异常安全性(new 或者 pb 的拷贝构造出错)

```c++
// 在开始加上
if (this == &rhs) return *this;
```

- 精心周到的语句顺序

```c++
Widget &Widget::operator= (const Widgte &rhs) {
    Bitmap *pOrig = pb;
    pb = new Widget(rhs.pb);
    delete pOrig;
    return *this;
}
```

- copy-and-swap （条款 29）

```c++
Widget &Widget::operator= (const Widgte &rhs) {
    Widget temp(rhs);
    swap(temp);			// 条款 29
    return *this;
}
// 以下：牺牲可读性，可以提升效率
Widget &Widget::operator= (Widgte rhs) {  // pass by value 构造了副本，
    swap(rhs);		
    return *this;
}
```

### 条款 12 ：复制对象时勿忘其每个成分

> 拷贝函数应该确保复制对象内的所有成员变量以及所有基类成分
>
> 不要尝试以某个拷贝函数实现另一个拷贝函数。应该将共同机能放进第三个函数中，并由两个拷贝函数共同调用

- 自己实现的拷贝构造和拷贝赋值即使执行了局部拷贝，编译器也不会报错
- 未拷贝基类成分时：拷贝构造函数中的基类成分使用使用默认构造函数构造，拷贝赋值运算符中的基类成分使用原来的值
- 具体实现

```c++
PriorityCustomer::PriorityCustomer (const PriorityCustomer &rhs) 
	: Customer(rhs)				// 调用基类拷贝构造函数
    , priority(rhs.priority){
    ...
}
PriorityCustomer &PriorityCustomer::operator= (const PriorityCustomer &rhs) {
    Customer::operator=(rhs);    // 调用基类拷贝赋值运算符
    priority = rhs.priority;
    ...
    return *this;
}
```

- 令拷贝赋值运算符调用拷贝构造函数是不合理的。试图构造一个以及存在的对象
- 令拷贝构造函数调用拷贝赋值运算符同意无意义。对尚未构造好的对象赋值

## 第三章 资源管理

### 条款 13 ：以对象管理资源

> 为防止资源泄露，请使用 RAII 管理对象，它们在构造函数中获得资源并在析构函数中释放资源。
>
> 被经常使用的 RAII 类是 shared_ptr 和 unique_ptr，前者通常是较佳选择，因为其拷贝行为比较直观。若选择 unique_ptr，std::move 会使得被复制一方为空。

- C++ 常使用的资源：动态分配内存、文件描述符、互斥锁、数据库连接、socket
- 关键思想
  - 获得资源后立刻放进管理对象内    ---->    资源取得时机便是初始化时机（RAII）
  - 管理对象运用析构函数确保资源被释放
- 在动态分配而得的数组身上使用 shared_ptr 等智能指针是个馊主意，因为有 vector、string 等容器是为更好的选择

```c++
std::shared_ptr<int> isp(new int[1024]);    // shared_ptr 在内部做 delete 动作，而不是delete[]，编译不会报错，但是会产生未定义行为
```

### 条款 14 ：在资源管理类中小心拷贝行为

> 复制 RAII 对象必须一并复制它所管理的资源，所以资源的拷贝行为决定 RAII 对象的拷贝行为
>
> 普遍而常见的 RAII 类拷贝行为是：禁用拷贝、引用计数

- 禁用拷贝：private成员、Uncopyable 类、=delete
- 引用计数：
- 复制：深拷贝
- 转移底部资源的在所有权：unique_ptr、std::move()

### 条款 15 ：在资源管理类中提供对原始资源的访问

> APIs 往往要求访问原始资源，所以每一个 RAII 类应该提供一个取得其所管理的资源的办法
>
> 对原始资源的访问可能经由显示转换或隐式转换，一般而言显示转换比较安全，但隐式转换对客户比较方便。

- 显示转换
  - shared_ptr 等智能指针的 get 成员函数
  - 重载指针取值操作符（operator->、operator*）
- 隐式转换
  - 重载 operator()

### 条款  16 ：成对使用 new 和 delete 时要采用相同形式

> 如果你在 new 表达式中使用 []，必须在相应的 delete 表达式中也使用 []。如果你在 new 表达式中不使用 []，一定不要在相应的 delete 表达式中使用 []。

### 条款 17 ：以独立语句将 new 创建的对象置入智能指针

> 以独立语句将 new 创建的对象置入智能指针。如果不这样做，一旦异常被抛出，有可能导致难以觉察的内存泄露。

```c++
int priority();
void process(std::shared_ptr<Widget> pw, int priority);

process(new Widget, priority());// 错误，shared_ptr 构造函数是 explicit，无法进行隐式转换
process(std::shared_ptr<Widget>(new Widget), priority());//正确，但是可能资源泄露
// 三个操作：执行 new Widget、调用 priority()、调用 std::shared_ptr 构造函数
// 三个的执行顺序不确定，可能是 1、2、3。如果对 priority() 的调用出错，则 new Widget 
// 返回的指针会泄露
```

- 编译器对语句内的各项操作有重新排列的自由，跨语句各项操作没有

- 在资源被创建和资源被转换为资源管理对象两个时间节点间可能发生异常干扰

```c++
std::shared_ptr<Widget> pw(new Widget);
process(pw, priority());
```

## 第四章 设计与声明

### 条款 18 ：让接口容易被正确使用，不易被错误使用

> 促进正确使用的方法：接口的一致性、与内置类型的行为兼容
>
> 阻止误用的方法：建立新类型、限制类型上的操作、束缚对象值、消除客户的资源管理责任
>
> shared_ptr 支持定制删除器。这可以防范 DLL 问题，可被用来自动解除互斥锁。
